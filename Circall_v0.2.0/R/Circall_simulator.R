#' Simulation function
#'
#' This function used to simulate both circRNA and tandem RNA RNA sequencing data base on given information.
#' @param circInfo a data frame that contains 6 columns which are: Chr, start_EXONSTART, end_EXONEND, GENEID, cCount and FPKM. Chr is chromosome name with formated as 1:22, X, Y, Mt. start_EXONSTART is starting position starting exon of circRNA, end_EXONEND is ending position ending exon of circRNA, GENEID is gene ID contains circRNA (used to get gene model), cCount are number of read pair want to generate for the target circRNA and FPKM are Fragments Per Kilobase of transcript per Million of target circRNAs. This is used to simulate circular RNAs
#' @param tandemInfo a data frame similar to circInfo to simulate tandem RNAs. tandemInfo=NULL (the default value) to not simulate tandem RNAs
#' @param error_rate sequencing error rate, the default value is 0.005
#' @param set.seed set seed for reproducibility, the default value is 2018
#' @param gtfSqlite path to your annotation file, Sqlite formated (generated by GenomicFeatures)
#' @param genomeFastaFile path to your genome fasta file
#' @param txFastaFile path to your transcript fasta file (cDNA)
#' @param out_name prefix output folders, the default value is "circAll_simuation"
#' @param out_dir the directory contains output, the default value is the current directory
#' @param lib_size expected library size used when useFPKM=TRUE, the default value is NULL
#' @param useFPKM boolean value to use FPKM or not, the default value is FALSE. When this useFPKM=TRUE, users need to set value for lib_size, and the simulator will use the abundance in column FPKM of circInfo/tandemInfo for simulation
#' @export




Circall_simulator <- function(circInfo,tandemInfo=NULL, error_rate = 0.005,set.seed = 2018,gtfSqlite,genomeFastaFile,txFastaFile,out_name = "Circall_simuation",out_dir = "./",libsize=NULL,useFPKM=FALSE,...){
	
	library("GenomicFeatures")
	library("Biostrings")
	library("polyester")

	# process annotation
	anntxdb <- loadDb(gtfSqlite)
	genes.all=genes(anntxdb,single.strand.genes.only=FALSE )
	genes.exon.all=select(anntxdb, keys=names(genes.all), columns=c("GENEID","TXNAME","EXONID","EXONSTART","EXONEND","EXONSTRAND","EXONCHROM"), keytype = "GENEID")
	#create exon-length # to get seqs from cDNA
	genes.exon.all$LENGTH =genes.exon.all$EXONEND - genes.exon.all$EXONSTART +1

	# process genome fasta
	fasta_genome = readDNAStringSet(genomeFastaFile)
	#format the name as 1,2,..X,Y,M..
	chnames=sapply(names(fasta_genome), function(x) unlist(strsplit(x," "))[1])
	#replace MT by M, so it is consistent with refseq annotation
	chnames[which(chnames=="MT")]="M"
	names(fasta_genome)=chnames

	#load tx.all.fasta and extract txname to dataframe
	tx.all.fasta = readDNAStringSet(txFastaFile)
	# to get seqs from cDNA
	# 19Apr2021/Dat: fix bug on hg38 annotation, tx names with '.version' after tx name
  tx.all.NAME = sapply(names(tx.all.fasta),function(x) unlist(strsplit(x," "))[1])
  tx.all.NAME = sapply(tx.all.NAME,function(x) unlist(strsplit(x,".", fixed = T))[1])

	cat("\n finished processing genome and transcripts" )


#	cat("\n Number of input BSJ is:" )
#	cat(nrow(BSJ_Info))
	
	set.seed(set.seed)
	#tandem_rate = 0.05
#	tandem_num = round(tandem_rate*nrow(BSJ_Info))
#	pick = sample(1:nrow(BSJ_Info), tandem_num)
#	tandemInfo = BSJ_Info[pick,]

	if(out_dir != "./") dir.create(out_dir)

#	if(nrow(tandemInfo) == 0){
#		circInfo = BSJ_Info
#		circInfo = simulate_circRNA(circInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir = out_dir,...)
#		cat("\n circRNA simulation is done! Number of simulated circRNA is:")
#		cat(nrow(circInfo))
#	}else{
#		circInfo = BSJ_Info[-pick,]
		circInfo = simulate_circRNA(circInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir = out_dir,libsize=libsize,useFPKM=useFPKM,...)
		cat("\n circRNA simulation is done! Number of simulated circRNA is: ",nrow(circInfo))
    if (!is.null(tandemInfo)){
  		tandemInfo = simulate_tandem(tandemInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir = out_dir,libsize=libsize,useFPKM=useFPKM,...)
  		cat("\n tandemRNA simulation is done! Number of simulated tandemRNA is: ",nrow(tandemInfo))
    }
#	}


	save(circInfo,tandemInfo,file = paste0(out_dir,"//",out_name,"_simulation_setting.Rdata"))
	return(list(circInfo = circInfo,tandemInfo = tandemInfo))
}




simulate_circRNA <- function(circInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir="./",libsize=NULL, useFPKM=FALSE,...){
  sim_dir = paste0(getwd(),"//tem_dir")
  dir.create(sim_dir) #make a temporary directory to simulate reads
  
  circ.tx.fa=DNAStringSet("ATGC")
  circInfo$normID=paste(circInfo$Chr,circInfo$start_EXONSTART,circInfo$end_EXONEND,sep="__")
  if (useFPKM) circInfo$cCount=0
  #circInfo$cCount= sample(100:1000,nrow(tandemInfo), replace = TRUE)
  TX_num=TXNAME=NULL
  for(i in 1: nrow(circInfo)){
    mycirR=circInfo[i,]
    #for simulated dataset
#    num_frag =mycirR$cCount
    circRNA_normID = circInfo$normID[i]
    mygene=as.character(mycirR$GENEID)
    myexonInfo=genes.exon.all[genes.exon.all$GENEID==mygene,]
    start=mycirR$start_EXONSTART
    end=mycirR$end_EXONEND
    #get all exons completely inside the boundary
    pick1=myexonInfo$EXONSTART == mycirR$start_EXONSTART
    pick2=myexonInfo$EXONEND == mycirR$end_EXONEND
    mytx=intersect(unique(myexonInfo[pick1,]$TXNAME), unique(myexonInfo[pick2,]$TXNAME))
    #select a single random transcript and generate circRNA from that transcript
    txNum=length(mytx)

    #restart for each loop
    circRNA.seq = NULL
    circRNA.name = NULL
    count = NULL
    juction_break = NULL

    if (txNum > 0){ # if existing transcripts containing both EXONSTART and EXONEND
      mytx=sample(mytx,1)
      for (atx in mytx){ #do for every tx
        mytxex=myexonInfo[myexonInfo$TXNAME==atx,]
        mytxex=mytxex[order(mytxex$EXONSTART),]
        mytxex.len = mytxex$LENGTH  
        #covert to transcript location
        mytxex.end.all =cumsum(mytxex$LENGTH)
        mytxex.stat.all = mytxex.end.all - mytxex.len +1 
        #select the coding area inside the circRNA region
        pick= which(mytxex$EXONSTART >= start & mytxex$EXONEND <= end) #pick by indexes of exons  
        startR= mytxex.stat.all[pick]
        endR= mytxex.end.all[pick]  
        ## generate pseudo circularRNAs sequences
        # - strand  
        if( mytxex$EXONSTRAND[1] == "-"){
            #pick transcript sequence
            transcript = convertReverseComplement(as.character(tx.all.fasta[which(tx.all.NAME == atx)]))
          }else{
            transcript = as.character(tx.all.fasta[which(tx.all.NAME == atx)])
          }  
        x=substring(transcript,startR,endR)
        txSeq=paste(x,collapse="")

        # correct to the right strand for "-"
        #if( mytxex$EXONSTRAND[1] == "-") txSeq=convertReverseComplement(txSeq)
        if (useFPKM){
          mycirR$cCount = round(mycirR$FPKM * nchar(txSeq) * (libsize/1e9))
          mycirR$cCount[ mycirR$cCount < 2 ] = 2
          circInfo$cCount[i]=mycirR$cCount
          #FPKM=(count/txlen)*1e9/libsize  
          #count=FPKM*libsize*txlen/1e9
        }

        num_frag =mycirR$cCount
        set.seed(2018)
        cvPos=sample(nchar(txSeq),num_frag,replace=TRUE)
        cv.fre=table(cvPos)
        cv.point=as.integer(names(cv.fre))
        startP=1
        endP=nchar(txSeq)
        r = substring(txSeq,cv.point)
        l= substring(txSeq,1,cv.point-1)
        l[which((cv.point-1)==0)] = "" #make sure no error for endding point =0
        atx.break = nchar(r)+1
        atx.seq = paste0(r,l)
        atx.name = paste0(circInfo$normID[i]," ",atx,",",txNum,",circRNA"," juction:",atx.break)
        circRNA.name = c(circRNA.name,atx.name)
        names(atx.seq) = atx.name
        atx.count = as.integer(cv.fre,names=FALSE)
        circRNA.seq = c(circRNA.seq,atx.seq)
        count = c(count,atx.count)
        juction_break =c(juction_break,atx.break)

        #collect for printing out
        circ_seq.raw=txSeq
        circ_name.raw = paste0(circInfo$normID[i]," ",atx,",",txNum,",circRNA")
        names(circ_seq.raw)=circ_name.raw
        circ.tx.fa=c(circ.tx.fa,DNAStringSet(circ_seq.raw))
      }
      circRNA.seq.fa = DNAStringSet(circRNA.seq)

    # exclude seq with width = 0, will be results in error later
      circRNA.seq.fa = circRNA.seq.fa[width(circRNA.seq.fa)>0]


      if(length(circRNA.seq.fa) <= 1){
      TX_num=c(TX_num,txNum)
      TXNAME=c( TXNAME,"skiping")
      next
       } 

      sim_dir_i = paste0(sim_dir,"//sim_",i)
      fasta_i = paste0(sim_dir,"//fasta_",i,".fasta")
      writeXStringSet(circRNA.seq.fa, fasta_i)
      unif.countmat = as.matrix(count)
      simulate_experiment_countmat(fasta_i, readmat=unif.countmat, outdir=sim_dir_i,error_rate = error_rate , strand_specific=FALSE,...)
      system(paste0("rm ",fasta_i))

    }else{ # if not existing the transcript, build circRNA from the exon contig between two ends
      mytx="NONE"
      #get all exons completely inside the boundary
      pick=myexonInfo$EXONSTART >= mycirR$start_EXONSTART & myexonInfo$EXONEND <= mycirR$end_EXONEND
      myex=myexonInfo[pick,]

      #in case of no exon available, skip this circRNA
      if(nrow(myex)==0){
          mytx="skiping"
      }else{
        #select the coding area inside the region. 
        #NOTE: this can not always satisfy the canonical splicing conditions (GT-AG), but we do not care about it this momment
        myex=myex[order(myex$EXONSTART),]
        exstart=myex$EXONSTART/1e6
        exend=myex$EXONEND/1e6
        #get clusters of exons
        exCluster=rep(-1,length(exstart))
        for (j in 1:length(exstart)){
          if (exCluster[j]==-1){
            exCluster[j]=j
            pick=(exstart[j]-exstart)*(exstart[j]-exend)<=0 | (exend[j]-exstart)*(exend[j]-exend)<=0
            #assign to the cluster with min index
            x=exCluster[pick]
            x=x[x>0]
            x=min(x)
            exCluster[pick]=x
          }
        }
        #update exCluster
        exCluster_u=exCluster
        repeat{
          exCluster=exCluster[exCluster]
          if (sum(exCluster_u!=exCluster)==0) break()
          exCluster_u=exCluster
        }
        #create exon regions from the exon clusters
        clusterID=sort(unique(exCluster))
        startR=endR=NULL
        for (j in 1:length(clusterID)){
          cID=clusterID[j]
          cEx=myex[exCluster==cID,]
          startR=c(startR,min(cEx$EXONSTART))
          endR=c(endR,max(cEx$EXONEND))
        }
        #sort again startR
        myorder=order(startR)
        startR=startR[myorder]
        endR=endR[myorder]
        # generate pseudo circularRNAs sequences
        #extract sequences and create a new transcript sequence
        chrID=as.character(myex$EXONCHROM)[1]
        x=substring(fasta_genome[chrID],startR,endR)
        txSeq=paste(x,collapse="")

        # correct to the right strand for "-"
        #if(myex$EXONSTRAND[1] == "-") txSeq=convertReverseComplement(txSeq)
        if (useFPKM){
          mycirR$cCount = round(mycirR$FPKM * nchar(txSeq) * (libsize/1e9))
          mycirR$cCount[ mycirR$cCount < 2 ] = 2
          circInfo$cCount[i]=mycirR$cCount
          #FPKM=(count/txlen)*1e9/libsize  
          #count=FPKM*libsize*txlen/1e9
        }
        num_frag =mycirR$cCount

        set.seed(2018) 
        cvPos=sample(nchar(txSeq),num_frag,replace=TRUE)
        cv.fre=table(cvPos)
        cv.point=as.integer(names(cv.fre))
        startP=1
        endP=nchar(txSeq)
        r = substring(txSeq,cv.point)
        l= substring(txSeq,1,cv.point-1)
        l[which((cv.point-1)==0)] = "" #make sure no error for endding point =0     
        juction_break = nchar(r)+1
        circRNA.seq = paste0(r,l)
        circRNA.name = paste0(circInfo$normID[i]," ",mytx,",",txNum,",circRNA"," juction:",juction_break)
        names(circRNA.seq) = circRNA.name
        circRNA.seq.fa = DNAStringSet(circRNA.seq)

        # exclude seq with width = 0, will be results in error later
        circRNA.seq.fa = circRNA.seq.fa[width(circRNA.seq.fa)>0]

        if(length(circRNA.seq.fa) <= 1){
          TX_num=c(TX_num,txNum)
          TXNAME=c( TXNAME,"skiping")
          next
        }

        #collect for printing out
        circ_seq.raw=txSeq
        circ_name.raw = paste0(circInfo$normID[i]," ",mytx,",",txNum,",circRNA")
        names(circ_seq.raw)=circ_name.raw
        circ.tx.fa=c(circ.tx.fa,DNAStringSet(circ_seq.raw))



        count = as.integer(cv.fre,names=FALSE)      
        sim_dir_i = paste0(sim_dir,"//sim_",i)
        fasta_i = paste0(sim_dir,"//fasta_",i,".fasta")
        writeXStringSet(circRNA.seq.fa, fasta_i)      
        unif.countmat = as.matrix(count)      
        simulate_experiment_countmat(fasta_i, readmat=unif.countmat, outdir=sim_dir_i,error_rate = error_rate , strand_specific=FALSE,...)
        system(paste0("rm ",fasta_i))

      }
  }    
    TX_num=c(TX_num,txNum)
    TXNAME=c( TXNAME,mytx)
  }  
  
  circ_out_dir = paste(out_dir,"/",out_name,"_circRNA_data",sep="")
  dir.create(circ_out_dir)

  circ.tx.fa=circ.tx.fa[-1]
  exportFasta=c(circ.tx.fa) # 
  fastaFile_circ=paste(out_dir,"/",out_name,"_circRNA.fa",sep="")
  writeXStringSet(exportFasta, fastaFile_circ)  # 


  circRead1=paste(circ_out_dir,"/read_1.fasta",sep="")
  circRead2=paste(circ_out_dir,"/read_2.fasta",sep="")

  cmd_cat1 = paste0("for fn in $(find ",sim_dir,' -type f -name "sample_01_1.fasta"); do cat $fn >> ',circRead1,"; done")
  cmd_cat2 = paste0("for fn in $(find ",sim_dir,' -type f -name "sample_01_2.fasta"); do cat $fn >> ',circRead2,"; done")
  system(cmd_cat1)
  system(cmd_cat2)
  system(paste0("rm -r ",sim_dir))
  res=cbind(circInfo,TX_num,TXNAME)
  pick=res$TXNAME=="skiping" #exclude the skipped circRNA candidates
  res=res[!pick,]
  return(res)
}


simulate_tandem <- function(tandemInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir="./",libsize=NULL, useFPKM=FALSE,...){
  tandem.tx.fa=DNAStringSet("ATGC")
  tandemInfo$normID=paste(tandemInfo$Chr,tandemInfo$start_EXONSTART,tandemInfo$end_EXONEND,sep="__")
  #tandemInfo$cCount= sample(100:1000,nrow(tandemInfo), replace = TRUE)
  for(i in 1: nrow(tandemInfo)){
      my_tandem=tandemInfo[i,]
      mynormID=my_tandem$normID
      tandem_gene=as.character(my_tandem$GENEID)
      tandem_exonInfo=genes.exon.all[genes.exon.all$GENEID==tandem_gene,]
      #get all exons completely inside the boundary
      pick1=tandem_exonInfo$EXONSTART == my_tandem$start_EXONSTART
      pick2=tandem_exonInfo$EXONEND == my_tandem$end_EXONEND
      tandem_tx=intersect(unique(tandem_exonInfo[pick1,]$TXNAME), unique(tandem_exonInfo[pick2,]$TXNAME))
      #select a single random transcript and generate tandem duplication from that transcript
      txNum=length(tandem_tx)
      start=my_tandem$start_EXONSTART
      end=my_tandem$end_EXONEND
      mytandem.tx.fa=DNAStringSet("ATGC") # starting tandem.tx.fa
      if (txNum > 0){mytx=sample(tandem_tx,1)}else{next}
      #Only genertate tandem duplication if existing transcripts containing both EXONSTART and EXONEND
        
        for (atx in mytx){ #do for every tx
          mytxex=tandem_exonInfo[tandem_exonInfo$TXNAME==atx,]
          mytxex=mytxex[order(mytxex$EXONSTART),]
          mytxex.len = mytxex$LENGTH # 
          #covert to transcript location
          mytxex.end.all =cumsum(mytxex$LENGTH)
          mytxex.stat.all = mytxex.end.all - mytxex.len +1
    
          #select the coding area inside the circRNA region
          pick= which(mytxex$EXONSTART >= start & mytxex$EXONEND <= end) #pick by indexes of exons # 
          startR= mytxex.stat.all[pick]
          endR= mytxex.end.all[pick]
          
          ## generate pseudo circularRNAs sequences
          # - strand    

          if( mytxex$EXONSTRAND[1] == "-"){
          #pick transcript sequence
            transcript = convertReverseComplement(as.character(tx.all.fasta[which(tx.all.NAME == atx)]))
          }else{
            transcript = as.character(tx.all.fasta[which(tx.all.NAME == atx)])
          }    

          x=substring(transcript,startR,endR)
          circSeq=paste(x,collapse="") # 
          #pick the left side
          pick.Left=which(mytxex$EXONEND < start) #pick by indexes
          x=""  
          start.Left= mytxex.stat.all[pick.Left]
          end.Left= mytxex.end.all[pick.Left]
          if(length(pick.Left)>0) x = substring(transcript,start.Left,end.Left)
          tandem_left.seq=paste0(x,collapse ="") 
          #pick the right side
          pick.Right=which(mytxex$EXONSTART > end)#pick by indexes
          x=""  
          start.Right= mytxex.stat.all[pick.Right]
          end.Right= mytxex.end.all[pick.Right]
          if(length(pick.Right)>0) x = substring(transcript,start.Right,end.Right)
          tandem_right.seq=paste0(x,collapse ="") # 
          #record tandem break point
          ##paste left side + circSeq and count nchar()
          A.seq = paste0(tandem_left.seq,circSeq)
          #tamdem_break[i] = as.numeric(nchar(A.seq))
          dup_point = as.numeric(nchar(A.seq))+1
          #tandem_normID = my_tandem$normID[1]
          tandem_stat = as.numeric(nchar(tandem_left.seq))+1
          tandem_end = dup_point + as.numeric(nchar(circSeq))
          # finish tandem.seq by pasting again circSeq + tandem_right.seq
          tandem.seq = paste0(A.seq,circSeq,tandem_right.seq) 
          
          ##convert back to the correct strand for - strand 
          #if( mytxex$EXONSTRAND[1] == "-") tandem.seq=convertReverseComplement(tandem.seq)
          

          #create tandemRNA.fa and return tadem.tx.fa
          tandem.name=paste(mynormID," ",atx," ",txNum," tandemRNA ",tandem_stat," ",dup_point," ",tandem_end, sep="")
          tandem.tx = DNAStringSet(tandem.seq)
          names(tandem.tx)= tandem.name
          mytandem.tx.fa=c(mytandem.tx.fa,tandem.tx)
        }
      mytandem.tx.fa=mytandem.tx.fa[-1]
      tandem.tx.fa=c(tandem.tx.fa,mytandem.tx.fa)
    }
  tandem.tx.fa=tandem.tx.fa[-1]

  #exclude transcripts with length is 0
  tandem.tx.fa = tandem.tx.fa[width(tandem.tx.fa)>0]

  simulated_info=lapply(names(tandem.tx.fa), function(x){
     y=unlist(strsplit(x," "))
     return(y)
    })
  #update tandemInfo
  simulated_info=do.call(rbind,simulated_info)
  simulated_info= as.data.frame(simulated_info,stringsAsFactors=FALSE)
  colnames(simulated_info)= c("normID","TXNAME","TX_num","tag","tandem_stat","tandem_break","tandem_end")
  tandemInfo = tandemInfo[tandemInfo$normID %in% simulated_info$normID,]
  tandemInfo= cbind(tandemInfo,simulated_info[,2:7])  

  #export to file
  #to RData # 
  #save(tandem.tx.fa, tandemInfo, file=paste(out_name,"_tandem_info.RData",sep="")) # 
  #to fa
  exportFasta=c(tandem.tx.fa) # 
  fastaFile_tandem=paste(out_dir,"/",out_name,"_tandem.fa",sep="")
  writeXStringSet(exportFasta, fastaFile_tandem)  # 
    
  #simulation for tandem dataset
  simPosdir = paste(out_dir,"/",out_name,"_tandem_data",sep="") # 
  library("polyester")
  library("Biostrings")
  #convert FPKM to count
  if (useFPKM){
    tandemInfo$cCount = round(tandemInfo$FPKM * width(tandem.tx.fa) * (libsize/1e9))
    tandemInfo$cCount[ tandemInfo$cCount < 2 ] = 2
    #FPKM=(count/txlen)*1e9/libsize  
    #count=FPKM*libsize*txlen/1e9
  }

  unif.countmat=tandemInfo$cCount
  unif.countmat=as.matrix(unif.countmat)
  simulate_experiment_countmat(fastaFile_tandem, readmat=unif.countmat, outdir=simPosdir,error_rate = error_rate, strand_specific=FALSE,...) # 
  return(tandemInfo)
}

convertReverseComplement<-function(DNAseq){
  DNAarr=unlist(strsplit(DNAseq,""))
  #reverse
  DNAarr=rev(DNAarr)
  #complement
  Aid=which(DNAarr=="A")
  Tid=which(DNAarr=="T")
  Gid=which(DNAarr=="G")
  Cid=which(DNAarr=="C")
  DNAarr[Aid]="T"
  DNAarr[Tid]="A"
  DNAarr[Gid]="C"
  DNAarr[Cid]="G"
  #result
  DNAseqRc=paste(DNAarr,collapse = "")
  return(DNAseqRc) 
}


