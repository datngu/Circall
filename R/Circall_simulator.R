#' Simulation function
#'
#' This function used to simulate both circRNA and tandem RNA RNA sequencing data base on given information.
#' @param BSJ_Info a data frame that contains 5 columns which are: Chr, start_EXONSTART, end_EXONEND, GENEID and TPM Chr is chromosome name with formated as 1:22, X, Y, Mt. start_EXONSTART is starting position starting exon of circRNA, end_EXONEND is ending position ending exon of circRNA, GENEID is gene ID contains circRNA (used to get gene model) and TPM are transcript per milion expression of target circRNA.
#' @param tandem_rate the rate tandem RNA that you wish to simulated eg. 0.2
#' @param error_rate sequencing error rate, defaut is 0.005
#' @param seed set seed for reproducibility, defaut is on with 2018
#' @param gtfSqlite path to your annotation file, Sqlite formated (generated by GenomicFeatures)
#' @param genomeFastaFile path to your genome fasta file
#' @param txFastaFile path to your transcript fasta file (cDNA)
#' @param out_name prefix output folders, defaut is "circAll_simuation"
#' @param out_dir the directory contains output, defaut is the current derectory
#' @export

# 31 March 2021
## update simulator in 
## fix bug on hg38 annotation, tx names with '.version' after tx name
## update simulator with TPM as input


  tx.all.NAME = sapply(names(tx.all.fasta),function(x) unlist(strsplit(x," "))[1])
  tx.all.NAME = sapply(names(tx.all.NAME),function(x) unlist(strsplit(x,".", fixed = T))[1])

Circall_simulator <- function(BSJ_Info,tandem_rate = 0,error_rate = 0.005, seed = 2018,gtfSqlite,genomeFastaFile,txFastaFile, lib_size = 100, out_name = "Circall_simuation",out_dir = "./",...){
  
  library("GenomicFeatures")
  library("Biostrings")
  library("polyester")

  # process annotation
  anntxdb <- loadDb(gtfSqlite)
  genes.all=genes(anntxdb,single.strand.genes.only=FALSE )
  genes.exon.all=select(anntxdb, keys=names(genes.all), columns=c("GENEID","TXNAME","EXONID","EXONSTART","EXONEND","EXONSTRAND","EXONCHROM"), keytype = "GENEID")
  #create exon-length # to get seqs from cDNA
  genes.exon.all$LENGTH =genes.exon.all$EXONEND - genes.exon.all$EXONSTART +1

  # process genome fasta
  fasta_genome = readDNAStringSet(genomeFastaFile)
  #format the name as 1,2,..X,Y,M..
  chnames=sapply(names(fasta_genome), function(x) unlist(strsplit(x," "))[1])
  #replace MT by M, so it is consistent with refseq annotation
  chnames[which(chnames=="MT")]="M"
  names(fasta_genome)=chnames

  tx.all.fasta = readDNAStringSet(txFastaFile)
  # to get seqs from cDNA
  ## fix bug on hg38 annotation, tx names with '.version' after tx name
  tx.all.NAME = sapply(names(tx.all.fasta),function(x) unlist(strsplit(x," "))[1])
  tx.all.NAME = sapply(names(tx.all.NAME),function(x) unlist(strsplit(x,".", fixed = T))[1])

  cat("\n finished processing genome and transcripts" )

  cat("\n Number of input BSJ is:" )
  cat(nrow(BSJ_Info))
  
  set.seed(seed)
  #tandem_rate = 0.05
  tandem_num = round(tandem_rate*nrow(BSJ_Info))
  pick = sample(1:nrow(BSJ_Info), tandem_num)
  tandemInfo = BSJ_Info[pick,]

  if(out_dir != "./") dir.create(out_dir)

  if(tandem_rate == 0){
    circInfo = BSJ_Info
    circInfo = simulate_circRNA(circInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir = out_dir, lib_size = lib_size)
    cat("\n circRNA simulation is done! Number of simulated circRNA is:")
    cat(nrow(circInfo))
  }else{
    circInfo = BSJ_Info[-pick,]
    circInfo = simulate_circRNA(circInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir = out_dir,lib_size = lib_size)

    cat("\n circRNA simulation is done! Number of simulated circRNA is:")
    cat(nrow(circInfo))

    tandemInfo = simulate_tandem(tandemInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir = out_dir,lib_size = lib_size)

    cat("\n tandemRNA simulation is done! Number of simulated tandemRNA is:")
    cat(nrow(tandemInfo))
  }

  save(circInfo,tandemInfo,file = paste0(out_dir,"//",out_name,"_simulation_setting.Rdata"))
  return(list(BSJ_Info = BSJ_Info,circInfo = circInfo,tandemInfo = tandemInfo))
}




simulate_circRNA <- function(circInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir="./", lib_size = 100,...){
  sim_dir = paste0(getwd(),"//tem_dir")
  dir.create(sim_dir) #make a temporary directory to simulate reads
  circInfo$TPM = circInfo$TPM * lib_size
  circ.tx.fa=DNAStringSet("ATGC")
  circInfo$normID=paste(circInfo$Chr,circInfo$start_EXONSTART,circInfo$end_EXONEND,sep="__")
  #circInfo$cCount= sample(100:1000,nrow(tandemInfo), replace = TRUE)
  TX_num=TXNAME=NULL
  for(i in 1: nrow(circInfo)){
    mycirR=circInfo[i,]
    #for simulated dataset
    num_frag = mycirR$TPM
    circRNA_normID = circInfo$normID[i]
    mygene=as.character(mycirR$GENEID)
    myexonInfo=genes.exon.all[genes.exon.all$GENEID==mygene,]
    start=mycirR$start_EXONSTART
    end=mycirR$end_EXONEND
    #get all exons completely inside the boundary
    pick1=myexonInfo$EXONSTART == mycirR$start_EXONSTART
    pick2=myexonInfo$EXONEND == mycirR$end_EXONEND
    mytx=intersect(unique(myexonInfo[pick1,]$TXNAME), unique(myexonInfo[pick2,]$TXNAME))
    #select a single random transcript and generate circRNA from that transcript
    txNum=length(mytx)

    #restart for each loop
    circRNA.seq = NULL
    circRNA.name = NULL
    count = NULL
    juction_break = NULL

    if (txNum > 0){ # if existing transcripts containing both EXONSTART and EXONEND
      mytx=sample(mytx,1)
      for (atx in mytx){ #do for every tx
        mytxex=myexonInfo[myexonInfo$TXNAME==atx,]
        mytxex=mytxex[order(mytxex$EXONSTART),]
        mytxex.len = mytxex$LENGTH  
        #covert to transcript location
        mytxex.end.all =cumsum(mytxex$LENGTH)
        mytxex.stat.all = mytxex.end.all - mytxex.len +1 
        #select the coding area inside the circRNA region
        pick= which(mytxex$EXONSTART >= start & mytxex$EXONEND <= end) #pick by indexes of exons  
        startR= mytxex.stat.all[pick]
        endR= mytxex.end.all[pick]  
        ## generate pseudo circularRNAs sequences
        # - strand  
        if( mytxex$EXONSTRAND[1] == "-"){
            #pick transcript sequence
            transcript = convertReverseComplement(as.character(tx.all.fasta[which(tx.all.NAME == atx)]))
          }else{
            transcript = as.character(tx.all.fasta[which(tx.all.NAME == atx)])
          }  
        x=substring(transcript,startR,endR)
        txSeq=""
        txSeq=paste(x,collapse="")

        # correct to the right strand for "-"
        #if( mytxex$EXONSTRAND[1] == "-") txSeq=convertReverseComplement(txSeq)
        
        #set.seed(set.seed)

        num_frag = round(num_frag*nchar(txSeq)/1000)
        if(num_frag < 1) num_frag = 1

        cvPos=sample(nchar(txSeq),num_frag,replace=TRUE)
        cv.fre=table(cvPos)
        cv.point=as.integer(names(cv.fre))
        startP=1
        endP=nchar(txSeq)
        r = substring(txSeq,cv.point)
        l = substring(txSeq,1,cv.point-1)
        l[which((cv.point-1)==0)] = "" #make sure no error for endding point =0
        atx.break = nchar(r)+1
        atx.seq = paste0(r,l)
        atx.name = paste0(circInfo$normID[i]," ",atx,",",txNum,",circRNA"," juction:",atx.break)
        circRNA.name = c(circRNA.name,atx.name)
        names(atx.seq) = atx.name
        atx.count = as.integer(cv.fre,names=FALSE)
        circRNA.seq = c(circRNA.seq,atx.seq)
        count = c(count,atx.count)
        juction_break =c(juction_break,atx.break)
      }
      circRNA.seq.fa = DNAStringSet(circRNA.seq)

    # exclude seq with width = 0, will be results in error later
      circRNA.seq.fa = circRNA.seq.fa[width(circRNA.seq.fa)>0]


      if(length(circRNA.seq.fa) <= 1){
      TX_num=c(TX_num,txNum)
      TXNAME=c( TXNAME,"skiping")
      next
       } 

      sim_dir_i = paste0(sim_dir,"//sim_",i)
      fasta_i = paste0(sim_dir,"//fasta_",i,".fasta")
      writeXStringSet(circRNA.seq.fa, fasta_i)
      unif.countmat = as.matrix(count)
      simulate_experiment_countmat(fasta_i, readmat=unif.countmat, outdir=sim_dir_i,error_rate = error_rate , strand_specific=FALSE,...)
      system(paste0("rm ",fasta_i))     
    }else{ # if not existing the transcript, build circRNA from the exon contig between two ends
      mytx="NONE"
      #get all exons completely inside the boundary
      pick=myexonInfo$EXONSTART >= mycirR$start_EXONSTART & myexonInfo$EXONEND <= mycirR$end_EXONEND
      myex=myexonInfo[pick,]

      #in case of no exon available, skip this circRNA
      if(nrow(myex)==0){
          mytx="skiping"
      }else{
        #select the coding area inside the region. 
        #NOTE: this can not always satisfy the canonical splicing conditions (GT-AG), but we do not care about it this momment
        myex=myex[order(myex$EXONSTART),]
        exstart=myex$EXONSTART/1e6
        exend=myex$EXONEND/1e6
        #get clusters of exons
        exCluster=rep(-1,length(exstart))
        for (j in 1:length(exstart)){
          if (exCluster[j]==-1){
            exCluster[j]=j
            pick=(exstart[j]-exstart)*(exstart[j]-exend)<=0 | (exend[j]-exstart)*(exend[j]-exend)<=0
            #assign to the cluster with min index
            x=exCluster[pick]
            x=x[x>0]
            x=min(x)
            exCluster[pick]=x
          }
        }
        #update exCluster
        exCluster_u=exCluster
        repeat{
          exCluster=exCluster[exCluster]
          if (sum(exCluster_u!=exCluster)==0) break()
          exCluster_u=exCluster
        }
        #create exon regions from the exon clusters
        clusterID=sort(unique(exCluster))
        startR=endR=NULL
        for (j in 1:length(clusterID)){
          cID=clusterID[j]
          cEx=myex[exCluster==cID,]
          startR=c(startR,min(cEx$EXONSTART))
          endR=c(endR,max(cEx$EXONEND))
        }
        #sort again startR
        myorder=order(startR)
        startR=startR[myorder]
        endR=endR[myorder]
        # generate pseudo circularRNAs sequences
        #extract sequences and create a new transcript sequence
        chrID=as.character(myex$EXONCHROM)[1]
        x=substring(fasta_genome[chrID],startR,endR)
        txSeq=paste(x,collapse="")

        # correct to the right strand for "-"
        #if(myex$EXONSTRAND[1] == "-") txSeq=convertReverseComplement(txSeq)
        
        #set.seed(set.seed)
        num_frag = round(num_frag*nchar(txSeq)/1000)
        if(num_frag < 1) num_frag = 1
        cvPos=sample(nchar(txSeq),num_frag,replace=TRUE)
        cv.fre=table(cvPos)
        cv.point=as.integer(names(cv.fre))
        startP=1
        endP=nchar(txSeq)
        r = substring(txSeq,cv.point)
        l= substring(txSeq,1,cv.point-1)
        l[which((cv.point-1)==0)] = "" #make sure no error for endding point =0     
        juction_break = nchar(r)+1
        circRNA.seq = paste0(r,l)
        circRNA.name = paste0(circInfo$normID[i]," ",mytx,",",txNum,",circRNA"," juction:",juction_break)
        names(circRNA.seq) = circRNA.name
        circRNA.seq.fa = DNAStringSet(circRNA.seq)

        # exclude seq with width = 0, will be results in error later
        circRNA.seq.fa = circRNA.seq.fa[width(circRNA.seq.fa)>0]

        if(length(circRNA.seq.fa) <= 1){
          TX_num=c(TX_num,txNum)
        TXNAME=c( TXNAME,"skiping")
          next
        } 


        count = as.integer(cv.fre,names=FALSE)      
        sim_dir_i = paste0(sim_dir,"//sim_",i)
        fasta_i = paste0(sim_dir,"//fasta_",i,".fasta")
        writeXStringSet(circRNA.seq.fa, fasta_i)      
        unif.countmat = as.matrix(count)      
        simulate_experiment_countmat(fasta_i, readmat=unif.countmat, outdir=sim_dir_i,error_rate = error_rate , strand_specific=FALSE)
        system(paste0("rm ",fasta_i))  
      }
    }    
    TX_num=c(TX_num,txNum)
    TXNAME=c( TXNAME,mytx)
  }
  
  circ_out_dir = paste(out_dir,"/",out_name,"_circRNA_data",sep="")
  dir.create(circ_out_dir)

  circRead1=paste(circ_out_dir,"/read_1.fasta",sep="")
  circRead2=paste(circ_out_dir,"/read_2.fasta",sep="")

  cmd_cat1 = paste0("for fn in $(find ",sim_dir,' -type f -name "sample_01_1.fasta"); do cat $fn >> ',circRead1,"; done")
  cmd_cat2 = paste0("for fn in $(find ",sim_dir,' -type f -name "sample_01_2.fasta"); do cat $fn >> ',circRead2,"; done")
  system(cmd_cat1)
  system(cmd_cat2)
  system(paste0("rm -r ",sim_dir))
  res=cbind(circInfo,TX_num,TXNAME)
  pick=res$TXNAME=="skiping" #exclude the skipped circRNA candidates
  res=res[!pick,]
  return(res)
}

simulate_tandem <- function(tandemInfo,error_rate,genes.exon.all,fasta_genome,tx.all.fasta,tx.all.NAME,out_name,out_dir="./",lib_size=100,...){
  tandem.tx.fa=DNAStringSet("ATGC")
  tandemInfo$TPM = tandemInfo$TPM * lib_size
  tandemInfo$normID=paste(tandemInfo$Chr,tandemInfo$start_EXONSTART,tandemInfo$end_EXONEND,sep="__")
  for(i in 1: nrow(tandemInfo)){
      my_tandem=tandemInfo[i,]
      mynormID=my_tandem$normID
      tandem_gene=as.character(my_tandem$GENEID)
      tandem_exonInfo=genes.exon.all[genes.exon.all$GENEID==tandem_gene,]
      #get all exons completely inside the boundary
      pick1=tandem_exonInfo$EXONSTART == my_tandem$start_EXONSTART
      pick2=tandem_exonInfo$EXONEND == my_tandem$end_EXONEND
      tandem_tx=intersect(unique(tandem_exonInfo[pick1,]$TXNAME), unique(tandem_exonInfo[pick2,]$TXNAME))
      #select a single random transcript and generate tandem duplication from that transcript
      txNum=length(tandem_tx)
      start=my_tandem$start_EXONSTART
      end=my_tandem$end_EXONEND
      mytandem.tx.fa=DNAStringSet("ATGC") # starting tandem.tx.fa
      if (txNum > 0){mytx=sample(tandem_tx,1)}else{next}
      #Only genertate tandem duplication if existing transcripts containing both EXONSTART and EXONEND
        
        for (atx in mytx){ #do for every tx
          mytxex=tandem_exonInfo[tandem_exonInfo$TXNAME==atx,]
          mytxex=mytxex[order(mytxex$EXONSTART),]
          mytxex.len = mytxex$LENGTH # 
          #covert to transcript location
          mytxex.end.all =cumsum(mytxex$LENGTH)
          mytxex.stat.all = mytxex.end.all - mytxex.len +1
    
          #select the coding area inside the circRNA region
          pick= which(mytxex$EXONSTART >= start & mytxex$EXONEND <= end) #pick by indexes of exons # 
          startR= mytxex.stat.all[pick]
          endR= mytxex.end.all[pick]
          
          ## generate pseudo circularRNAs sequences
          # - strand    

          if( mytxex$EXONSTRAND[1] == "-"){
          #pick transcript sequence
            transcript = convertReverseComplement(as.character(tx.all.fasta[which(tx.all.NAME == atx)]))
          }else{
            transcript = as.character(tx.all.fasta[which(tx.all.NAME == atx)])
          }    

          x=substring(transcript,startR,endR)
          circSeq=paste(x,collapse="") # 
          #pick the left side
          pick.Left=which(mytxex$EXONEND < start) #pick by indexes
          x=""  
          start.Left= mytxex.stat.all[pick.Left]
          end.Left= mytxex.end.all[pick.Left]
          if(length(pick.Left)>0) x = substring(transcript,start.Left,end.Left)
          tandem_left.seq=paste0(x,collapse ="") 
          #pick the right side
          pick.Right=which(mytxex$EXONSTART > end)#pick by indexes
          x=""  
          start.Right= mytxex.stat.all[pick.Right]
          end.Right= mytxex.end.all[pick.Right]
          if(length(pick.Right)>0) x = substring(transcript,start.Right,end.Right)
          tandem_right.seq=paste0(x,collapse ="") # 
          #record tandem break point
          ##paste left side + circSeq and count nchar()
          A.seq = paste0(tandem_left.seq,circSeq)
          #tamdem_break[i] = as.numeric(nchar(A.seq))
          dup_point = as.numeric(nchar(A.seq))+1
          #tandem_normID = my_tandem$normID[1]
          tandem_stat = as.numeric(nchar(tandem_left.seq))+1
          tandem_end = dup_point + as.numeric(nchar(circSeq))
          # finish tandem.seq by pasting again circSeq + tandem_right.seq
          tandem.seq = paste0(A.seq,circSeq,tandem_right.seq) 
          
          ##convert back to the correct strand for - strand 
          #if( mytxex$EXONSTRAND[1] == "-") tandem.seq=convertReverseComplement(tandem.seq)
          

          #create tandemRNA.fa and return tadem.tx.fa
          tandem.name=paste(mynormID," ",atx," ",txNum," tandemRNA ",tandem_stat," ",dup_point," ",tandem_end, sep="")
          tandem.tx = DNAStringSet(tandem.seq)
          names(tandem.tx)= tandem.name
          mytandem.tx.fa=c(mytandem.tx.fa,tandem.tx)
        }
      mytandem.tx.fa=mytandem.tx.fa[-1]
      tandem.tx.fa=c(tandem.tx.fa,mytandem.tx.fa)
    }
  tandem.tx.fa=tandem.tx.fa[-1]

  #exclude transcripts with length is 0
  tandem.tx.fa = tandem.tx.fa[width(tandem.tx.fa)>0]

  simulated_info=lapply(names(tandem.tx.fa), function(x){
     y=unlist(strsplit(x," "))
     return(y)
    })
  #update tandemInfo
  simulated_info=do.call(rbind,simulated_info)
  simulated_info= as.data.frame(simulated_info,stringsAsFactors=FALSE)
  colnames(simulated_info)= c("normID","TXNAME","TX_num","tag","tandem_stat","tandem_break","tandem_end")
  # tandemInfo$normID = paste(tandemInfo$Chr, tandemInfo$start_EXONSTART, tandemInfo$end_EXONEND, sep = "__")
  tandemInfo = tandemInfo[tandemInfo$normID %in% simulated_info$normID,]
  tandemInfo= cbind(tandemInfo,simulated_info[,2:7])  

  #export to file
  #to RData # 
  #save(tandem.tx.fa, tandemInfo, file=paste(out_name,"_tandem_info.RData",sep="")) # 
  #to fa
  exportFasta=c(tandem.tx.fa) # 
  fastaFile_tandem=paste(out_dir,"/",out_name,"_tandem.fa",sep="")
  writeXStringSet(exportFasta, fastaFile_tandem)  # 
    
  #simulation for tandem dataset
  simPosdir = paste(out_dir,"/",out_name,"_tandem_data",sep="") # 
  library("polyester")
  library("Biostrings")
  tandemInfo$count = round( width(tandem.tx.fa) * tandemInfo$TPM/1000)
  unif.countmat= tandemInfo$count# 
  unif.countmat=as.matrix(unif.countmat)
  simulate_experiment_countmat(fastaFile_tandem, readmat=unif.countmat, outdir=simPosdir,error_rate = error_rate, strand_specific=FALSE,...) # 
  return(tandemInfo)
}


convertReverseComplement<-function(DNAseq){
  DNAarr=unlist(strsplit(DNAseq,""))
  #reverse
  DNAarr=rev(DNAarr)
  #complement
  Aid=which(DNAarr=="A")
  Tid=which(DNAarr=="T")
  Gid=which(DNAarr=="G")
  Cid=which(DNAarr=="C")
  DNAarr[Aid]="T"
  DNAarr[Tid]="A"
  DNAarr[Gid]="C"
  DNAarr[Cid]="G"
  #result
  DNAseqRc=paste(DNAarr,collapse = "")
  return(DNAseqRc) 
}

